# Open the terminal and execute the following commands
# This one just once to create the server.crt and server.key files for the postgres container, this allows the db container to use ssl
# docker run --rm -it -v $PWD:/app -w /app alpine /bin/sh -c "apk add openssl && mkdir -p postgres-ca && cd postgres-ca && openssl req -new -text -passout pass:abcd -subj /CN=lopostgres-calhost -out server.req && openssl rsa -in privkey.pem -passin pass:abcd -out server.key && openssl req -x509 -in server.req -text -key server.key -out server.crt"
# rather overkill, but whatever
# then 
# docker-compose up --build
# avoid doing stuff until the api server is up and running and you see "Server is running on port 3000", it takes a while to start, so be patient
# go to localhost:80 to see the admin interface
# after updating the api code, wait for the api server to be up and running again.

version: "3.4"
services:

  # Installs the dependencies
  dep:
    image: node:20-alpine
    platform: linux/amd64
    container_name: dependencies_installer
    entrypoint: ["/bin/sh", "-c", "corepack enable && echo 'y' | pnpm install --frozen-lockfile"]
    volumes:
      - "./:/app"
    working_dir: /app
    tty: true

  # It needs the server.crt and server.key files in the postgres-ca directory first, check the command in the top comment
  db:
    image: postgres:16-alpine
    platform: linux/amd64
    container_name: db
    command: -c ssl=on -c ssl_cert_file=/var/lib/postgresql/server.crt -c ssl_key_file=/var/lib/postgresql/server.key
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=username
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=database
    volumes:
      - ./postgres-ca/server.crt:/var/lib/postgresql/server.crt:ro
      - ./postgres-ca/server.key:/var/lib/postgresql/server.key:ro

  # Waits for the dep container to be down, then waits for the db container to be up, then starts the database migration
  db_migrate:
    image: node:20-alpine
    platform: linux/amd64
    container_name: db_migrate
    entrypoint: ["/bin/sh", "-c", "while ping -c1 dep &>/dev/null; do sleep 3; done; while ! ping -c1 db &>/dev/null; do sleep 3; done; cd ./packages/database && corepack enable && echo 'y' | pnpm run migrate"]
    volumes:
      - type: bind
        source: ./
        target: /app
    working_dir: /app
    tty: true
    links:
      - dep
      - db
    environment:
      - DATABASE_URL=postgres://username:password@db:5432/database

  # Waits for the dep, then waits for the db container to be up, then starts the api environment
  api:
    image: node:20-alpine
    platform: linux/amd64
    container_name: api
    entrypoint: ["/bin/sh", "-c", "while ping -c1 dep &>/dev/null; do sleep 3; done; while ! ping -c1 db &>/dev/null; do sleep 3; done; cd ./packages/api && corepack enable && echo 'y' | pnpm run dev"]
    ports:
      - 3000:3000
    volumes:
      - "./:/app"
      - "~/.aws/:/root/.aws/"
    working_dir: /app
    tty: true
    links:
      - dep
      - db
      - db_migrate
    environment:
      - DATABASE_URL=postgres://username:password@db:5432/database
      - AWS_REGION=us-east-1
      # These are environment variables that should be set in the .env file, check the .env.example file
      - PHOTOS_BUCKET=${PHOTOS_BUCKET} 
      - AWS_PROFILE=${AWS_PROFILE}

  # Waits for the dep container to be down and the api container to be up, then starts the admin environment
  admin:
    image: node:20-alpine
    platform: linux/amd64
    container_name: admin
    entrypoint: ["/bin/sh", "-c", "while ping -c1 dep &>/dev/null; do sleep 3; done; cd ./packages/admin && corepack enable && echo 'y' | pnpm run dev"]
    ports:
      - 3001:3001
    volumes:
      - "./:/app"
    working_dir: /app
    tty: true
    links:
      - dep
      - api

  # Connects to the admin and api containers for some nice routing
  nginx:
    image: nginx:alpine
    platform: linux/amd64
    container_name: nginx
    entrypoint: ["/bin/sh", "-c", "echo 'server { listen 80; server_name localhost; location /api {proxy_pass http://api:3000/api; } location / { proxy_pass http://admin:3001; } }' > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"]
    ports:
      - 80:80
    links:
     - admin
     - api

# All of the waiting for the containers to be up is done with the ping command, it's not the best way to do it, I think, but it works
# we can add a volume for the db if we want to persist the data
